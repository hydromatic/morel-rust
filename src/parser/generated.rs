// Licensed to Julian Hyde under one or more contributor license
// agreements.  See the NOTICE file distributed with this work
// for additional information regarding copyright ownership.
// Julian Hyde licenses this file to you under the Apache
// License, Version 2.0 (the "License"); you may not use this
// file except in compliance with the License.  You may obtain a
// copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
// either express or implied.  See the License for the specific
// language governing permissions and limitations under the
// License.

use pest::Parser;
use pest_derive::Parser;

/// A parser for the Morel language generated by Pest.
#[derive(Parser)]
#[grammar = "src/parser/morel.pest"]
struct MorelParser;

pub fn parse(input: &str) {
    match MorelParser::parse(Rule::literal, input) {
        Ok(pairs) => {
            for pair in pairs {
                println!("Parsed field: {:?}", pair.as_str());
            }
        }
        Err(e) => {
            eprintln!("Failed to parse input: {}", e);
        }
    }
}

#[cfg(test)]
mod test {
    use crate::parser::generated::Rule;
    use crate::parser::generated::Rule::{char_literal, string_literal};
    use Rule::{literal, numeric_literal};
    use pest::iterators::Pair;

    /// Test fixture.
    struct Fixture {
        s: String,
    }

    impl Fixture {
        pub(crate) fn ok(&self) {
            use super::MorelParser;
            use pest::Parser;

            let result = MorelParser::parse(literal, self.s.as_str());
            assert!(
                result.is_ok(),
                "For [{}], expected successful parse, got: {:?}",
                self.s,
                result
            );
        }

        pub(crate) fn fail(&self) {
            use super::MorelParser;
            use pest::Parser;

            let result = MorelParser::parse(literal, self.s.as_str());
            assert!(
                result.is_err(),
                "For [{}], expected parse to fail, got: {:?}",
                self.s,
                result
            );
        }

        pub(crate) fn assert_parse(&self, rule: Rule, expected_rule: Rule) {
            use super::MorelParser;
            use pest::Parser;

            let result = MorelParser::parse(rule, self.s.as_str());
            let file = result.expect("parse should succeed").next().unwrap();
            let matcher = &is_a(expected_rule, is(self.s.as_str()));
            for line in file.into_inner() {
                matcher(&line);
            }
        }
    }

    /// Creates a fixture with a given piece of code.
    fn ml(s: &str) -> Fixture {
        Fixture { s: s.to_string() }
    }

    /// Creates a matcher that asserts the string is equal to `expected`.
    fn is(expected: &str) -> impl Fn(&str) {
        move |actual: &str| {
            assert_eq!(
                actual, expected,
                "Expected string [{}], got [{}]",
                expected, actual
            );
        }
    }

    /// Creates a matcher that asserts a line is of a given syntactic type and
    /// matches a given string.
    fn is_a(rule: Rule, matcher: impl Fn(&str)) -> impl Fn(&Pair<Rule>) {
        move |line: &Pair<Rule>| {
            if line.as_rule() == rule {
                matcher(line.as_str());
            } else {
                assert!(false, "Unexpected rule: {:?}", line);
            }
        }
    }

    #[test]
    fn test_morel_parser() {
        ml("1").assert_parse(literal, numeric_literal);
        ml("~3.5").assert_parse(literal, numeric_literal);
        ml("\"a string\"").assert_parse(literal, string_literal);
        ml("\"\"").assert_parse(literal, string_literal);
        ml("\"a\\\\b\\\"c\"").assert_parse(literal, string_literal);
        ml("#\"a\"").assert_parse(literal, char_literal);
        ml("#\"\\\"\"").assert_parse(literal, char_literal);
        ml("#\"\\\\\"").assert_parse(literal, char_literal);
        ml("123.45").ok();
        ml("\"a string\"").ok();
        ml("#\"a\"").ok();
        ml("not a number").fail();
    }
}
