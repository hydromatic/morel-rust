// Licensed to Julian Hyde under one or more contributor license
// agreements.  See the NOTICE file distributed with this work
// for additional information regarding copyright ownership.
// Julian Hyde licenses this file to you under the Apache
// License, Version 2.0 (the "License"); you may not use this
// file except in compliance with the License.  You may obtain a
// copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
// either express or implied.  See the License for the specific
// language governing permissions and limitations under the
// License.

use crate::parser::ast;
use crate::parser::ast::Node;
use pest::Parser;
use pest_derive::Parser;

/// A parser for the Morel language generated by Pest.
#[derive(Parser)]
#[grammar = "src/parser/morel.pest"]
struct MorelParser;

pub fn parse(input: &str) -> Node<'_> {
    let mut pairs =
        MorelParser::parse(Rule::literal, input).expect("should be valid");
    if let Some(pair) = pairs.next() {
        match pair.as_rule() {
            Rule::expr => Node::Expr(ast::build_expr(pair)),
            Rule::decl => Node::Decl(ast::build_decl(pair)),
            _ => panic!("Unexpected rule: {:?}", pair.as_rule()),
        }
    } else {
        panic!("Empty");
    }
}

#[cfg(test)]
mod test {
    use crate::parser::ast;
    use crate::parser::ast::Ast;
    use crate::parser::parser::Rule;
    use pest::iterators::Pair;
    use pest::Parser;

    /// Test fixture.
    struct Fixture {
        s: String,
    }

    impl Fixture {
        fn assert_build(&self, matcher: impl Fn(&str)) {
            use super::MorelParser;

            let result = MorelParser::parse(Rule::statement, self.s.as_str());
            let expr = ast::build_program(
                result.expect("should parse").next().unwrap(),
            );
            let mut s = String::new();
            expr.unparse(&mut s);
            matcher(&s);
        }
    }

    impl Fixture {
        pub(crate) fn ok(&self) {
            use super::MorelParser;
            use pest::Parser;

            let result = MorelParser::parse(Rule::literal, self.s.as_str());
            assert!(
                result.is_ok(),
                "For [{}], expected successful parse, got: {:?}",
                self.s,
                result
            );
        }

        pub(crate) fn fail(&self) {
            use super::MorelParser;
            use pest::Parser;

            let result = MorelParser::parse(Rule::literal, self.s.as_str());
            assert!(
                result.is_err(),
                "For [{}], expected parse to fail, got: {:?}",
                self.s,
                result
            );
        }

        pub(crate) fn assert_parse(&self, rule: Rule, expected_rule: Rule) {
            use super::MorelParser;
            use pest::Parser;

            let result = MorelParser::parse(rule, self.s.as_str());
            let file = result.expect("parse should succeed").next().unwrap();
            let matcher = &is_a(expected_rule, is(self.s.as_str()));
            let mut count = 0;
            for line in file.into_inner() {
                matcher(&line);
                count = count + 1;
            }
            assert_eq!(
                count, 1,
                "Expected exactly one match for [{}], got [{}]",
                self.s, count
            );
        }
    }

    /// Creates a fixture with a given piece of code.
    fn ml(s: &str) -> Fixture {
        Fixture { s: s.to_string() }
    }

    /// Creates a matcher that asserts the string is equal to `expected`.
    fn is(expected: &str) -> impl Fn(&str) {
        move |actual: &str| {
            assert_eq!(
                actual, expected,
                "Expected string [{}], got [{}]",
                expected, actual
            );
        }
    }

    /// Creates a matcher that asserts a line is of a given syntactic type and
    /// matches a given string.
    fn is_a(rule: Rule, matcher: impl Fn(&str)) -> impl Fn(&Pair<Rule>) {
        move |line: &Pair<Rule>| {
            assert_eq!(
                rule,
                line.as_rule(),
                "Expected rule {:?}, got {:?} for line [{}]",
                rule,
                line.as_rule(),
                line.as_str()
            );
            matcher(line.as_str());
        }
    }

    #[test]
    fn test_parse() {
        ml("1").assert_parse(Rule::literal, Rule::numeric_literal);
        ml("~3.5").assert_parse(Rule::literal, Rule::numeric_literal);
        ml("\"a string\"").assert_parse(Rule::literal, Rule::string_literal);
        ml("\"\"").assert_parse(Rule::literal, Rule::string_literal);
        ml("\"a\\\\b\\\"c\"").assert_parse(Rule::literal, Rule::string_literal);
        ml("#\"a\"").assert_parse(Rule::literal, Rule::char_literal);
        ml("#\"\\\"\"").assert_parse(Rule::literal, Rule::char_literal);
        ml("#\"\\\\\"").assert_parse(Rule::literal, Rule::char_literal);
        ml("123.45").ok();
        ml("\"a string\"").ok();
        ml("#\"a\"").ok();
        ml("not a number").fail();
    }

    #[test]
    fn test_parse_decl() {
        ml("1").assert_parse(Rule::expr, Rule::literal);
        ml("xyz").assert_parse(Rule::expr, Rule::identifier);
        ml("xyz").assert_parse(Rule::statement, Rule::expr);
        ml("val x = 5").assert_parse(Rule::statement, Rule::decl);
        ml("val `x` = 5").assert_parse(Rule::statement, Rule::decl);
    }

    #[test]
    fn test_parse_build() {
        ml("1").assert_build(&is("1"));
        ml("val x = 5").assert_build(&is("val x = 5"));
    }
}
