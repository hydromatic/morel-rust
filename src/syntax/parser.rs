// Licensed to Julian Hyde under one or more contributor license
// agreements.  See the NOTICE file distributed with this work
// for additional information regarding copyright ownership.
// Julian Hyde licenses this file to you under the Apache
// License, Version 2.0 (the "License"); you may not use this
// file except in compliance with the License.  You may obtain a
// copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
// either express or implied.  See the License for the specific
// language governing permissions and limitations under the
// License.

use crate::syntax::ast::{
    ConBind, DatatypeBind, Decl, DeclKind, Expr, ExprKind, FunBind, FunMatch,
    Label, LabeledExpr, Literal, LiteralKind, Match, Pat, PatField, PatKind,
    Span, Statement, StatementKind, Step, StepKind, Type, TypeBind, TypeField,
    TypeKind, TypeScheme, ValBind,
};
use pest_consume::Parser;
use pest_consume::match_nodes;
use std::rc::Rc;

type ParseInput<'input> = pest_consume::Node<'input, Rule, Rc<str>>;

pub type ParseError = pest::error::Error<Rule>;
pub type ParseResult<T> = Result<T, ParseError>;

/// Morel language parser generated by Pest.
#[derive(Parser)]
#[grammar = "src/syntax/morel.pest"]
pub struct MorelParser;

/// Parses a Morel statement and returns its AST.
///
/// The statement may be preceded by whitespace and/or comments;
/// the statement must end with a semicolon.
#[allow(clippy::result_large_err)]
pub fn parse_statement(input: &str) -> ParseResult<Statement> {
    let rc_input_str: Rc<str> = input.to_string().into();
    let nodes = MorelParser::parse_with_userdata(
        Rule::statement_plus,
        input,
        rc_input_str,
    )?;
    Ok(match_nodes!(<MorelParser>; nodes;
        [statement_plus(e)] => e,
    ))
}

/// Parses a statement (with no whitespace, comments or semicolon)
/// and returns its AST.
#[allow(clippy::result_large_err)]
pub fn parse_unadorned_statement(input: &str) -> ParseResult<Statement> {
    let rc_input_str = input.to_string().into();
    let nodes =
        MorelParser::parse_with_userdata(Rule::statement, input, rc_input_str)?;
    Ok(match_nodes!(<MorelParser>; nodes;
        [statement(s)] => s,
    ))
}

/// Parses a Morel type scheme and returns its AST.
#[allow(clippy::result_large_err)]
pub fn parse_type_scheme(input: &str) -> ParseResult<TypeScheme> {
    let rc_input_str: Rc<str> = input.to_string().into();
    let nodes = MorelParser::parse_with_userdata(
        Rule::type_scheme_top,
        input,
        rc_input_str,
    )?;
    Ok(match_nodes!(<MorelParser>; nodes;
        [type_scheme_top(e)] => e,
    ))
}

fn input_to_span(input: &ParseInput) -> Span {
    Span::make(input.user_data().clone(), input.as_pair().as_span())
}

impl LiteralKind {
    #[allow(clippy::needless_pass_by_value)]
    pub fn wrap(&self, input: ParseInput) -> Literal {
        self.spanned(&input_to_span(&input))
    }
}

impl ExprKind<Expr> {
    #[allow(clippy::needless_pass_by_value)]
    pub fn as_statement(&self, input: ParseInput) -> Statement {
        Statement {
            kind: StatementKind::Expr(self.clone()),
            span: input_to_span(&input),
            id: None,
        }
    }

    #[allow(clippy::needless_pass_by_value)]
    pub fn wrap(&self, input: ParseInput) -> Expr {
        self.spanned(&input_to_span(&input))
    }
}

impl DeclKind {
    #[allow(clippy::needless_pass_by_value)]
    pub fn as_statement(&self, input: ParseInput) -> Statement {
        Statement {
            kind: StatementKind::Decl(self.clone()),
            span: input_to_span(&input),
            id: None,
        }
    }

    #[allow(clippy::needless_pass_by_value)]
    pub fn wrap(&self, input: ParseInput) -> Decl {
        self.spanned(&input_to_span(&input))
    }
}

impl PatKind {
    #[allow(clippy::needless_pass_by_value)]
    pub fn wrap(&self, input: ParseInput) -> Pat {
        self.spanned(&input_to_span(&input))
    }
}

impl TypeKind {
    #[allow(clippy::needless_pass_by_value)]
    pub fn wrap(&self, input: ParseInput) -> Type {
        self.spanned(&input_to_span(&input))
    }
}

impl StepKind {
    #[allow(clippy::needless_pass_by_value)]
    pub fn wrap(&self, input: ParseInput) -> Step {
        self.spanned(&input_to_span(&input))
    }
}

#[pest_consume::parser(parser = MorelParser)]
impl MorelParser {
    fn statement_plus(input: ParseInput) -> ParseResult<Statement> {
        Ok(match_nodes!(input.children();
            [statement(s), EOI(_)] => s,
        ))
    }

    fn statement(input: ParseInput) -> ParseResult<Statement> {
        Ok(match_nodes!(input.children();
            [expr(e)] => e.kind.as_statement(input),
            [decl(d)] => d.kind.as_statement(input),
        ))
    }

    fn expr(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [expr_annotated(e)] => e,
        ))
    }

    fn expr_annotated(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [expr_implies(e)] => e,
            [expr_implies(e), type_(t)] => {
                ExprKind::Annotated(Box::new(e), Box::new(t)).wrap(input)
            },
        ))
    }

    fn expr_implies(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [expr_orelse(e1), expr_implies_arg(e2)..] => {
                fold2(&e1, &e2.collect(), |x, y| { ExprKind::Implies(x, y) })
            },
        ))
    }

    fn expr_implies_arg(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [_implies(_), expr_orelse(e)] => e
        ))
    }

    fn expr_orelse(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [expr_andalso(e1), expr_orelse_arg(e2)..] => {
                fold2(&e1, &e2.collect(), |x, y| { ExprKind::OrElse(x, y) })
            },
        ))
    }

    fn expr_orelse_arg(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [_orelse(_), expr_andalso(e)] => e
        ))
    }

    fn expr_andalso(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [expr_o(e1), expr_andalso_arg(e2)..] => {
                fold2(&e1, &e2.collect(), |x, y| { ExprKind::AndAlso(x, y) })
            },
        ))
    }

    fn expr_andalso_arg(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [_andalso(_), expr_o(e)] => e
        ))
    }

    fn expr_o(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [expr_comp(e)] => e,
            [expr_comp(e1), expr_o_arg(e2)..] => {
                fold2(&e1, &e2.collect(), |x, y| { ExprKind::Compose(x, y) })
            },
        ))
    }

    fn expr_o_arg(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [_o(_), expr_comp(e)] => e
        ))
    }

    fn expr_comp(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [expr_cons(e), expr_comp_arg(args)..] => {
                fold_heterogeneous(&e, &args.collect(), |op, x, y| {
                    match op {
                        "=" => ExprKind::Equal(x, y),
                        "<>" => ExprKind::NotEqual(x, y),
                        "<" => ExprKind::LessThan(x, y),
                        "<=" => ExprKind::LessThanOrEqual(x, y),
                        ">" => ExprKind::GreaterThan(x, y),
                        ">=" => ExprKind::GreaterThanOrEqual(x, y),
                        "elem" => ExprKind::Elem(x, y),
                        "notelem" => ExprKind::NotElem(x, y),
                        _ => unreachable!("Unexpected comparison operator {}",
                            op),
                   }
                })
            },
        ))
    }

    fn expr_comp_arg(input: ParseInput<'_>) -> ParseResult<(&str, Expr)> {
        Ok(match_nodes!(input.children();
            [expr_comp_op(op), expr_cons(e)] => (op, e)))
    }

    fn expr_comp_op(input: ParseInput<'_>) -> ParseResult<&str> {
        Ok(input.as_str())
    }

    fn expr_cons(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [expr_additive(e), expr_cons_arg(args)..] => {
                // Cons and append are right-associative, but we had to
                // build the list from left-to-right, to avoid recursion.
                // So we need to reverse.
                //
                // For the expression
                //   1 :: 2 @ 3 :: 4 :: 5
                // we get
                //   e = 1, args = [(::, 2), (@, 3), (::, 4), (:: 5)].
                // But we need
                //   e2 = 5, args2 = [(::, 4), (::, 3), (@, 2), (::, 1)].
                let mut e2 = e;
                let mut args2 = Vec::new();
                for (op, arg) in args {
                    args2.insert(0, (op, e2));
                    e2 = arg;
                }

                // Now fold, as we did for the left-associative operators, but
                // reversing x and y.
                fold_heterogeneous(&e2, &args2, |op, x, y| {
                    match op {
                        "::" => ExprKind::Cons(y, x),
                        "@" => ExprKind::Append(y, x),
                        _ => unreachable!("Unexpected cons operator {}", op),
                    }
                })
            },
        ))
    }

    fn expr_cons_arg(input: ParseInput<'_>) -> ParseResult<(&str, Expr)> {
        Ok(match_nodes!(input.children();
            [expr_cons_op(op), expr_cons(e)] => (op, e)))
    }

    fn expr_cons_op(input: ParseInput<'_>) -> ParseResult<&str> {
        Ok(input.as_str())
    }

    fn expr_additive(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [expr_multiplicative(e), expr_additive_arg(args)..] => {
                fold_heterogeneous(&e, &args.collect(), |op, x, y| {
                    match op {
                        "+" => ExprKind::Plus(x, y),
                        "-" => ExprKind::Minus(x, y),
                        "^" => ExprKind::Caret(x, y),
                        _ => unreachable!(
                            "Unexpected additive operator {}", op
                        ),
                    }
                })
            },
        ))
    }

    fn expr_additive_arg(input: ParseInput<'_>) -> ParseResult<(&str, Expr)> {
        Ok(match_nodes!(input.children();
            [expr_additive_op(op), expr_multiplicative(e)] => (op, e)))
    }

    fn expr_additive_op(input: ParseInput<'_>) -> ParseResult<&str> {
        Ok(input.as_str())
    }

    fn expr_multiplicative(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [expr_over(e), expr_multiplicative_arg(args)..] => {
                fold_heterogeneous(&e, &args.collect(), |op, x, y| {
                    match op {
                        "*" => ExprKind::Times(x, y),
                        "/" => ExprKind::Divide(x, y),
                        "div" => ExprKind::Div(x, y),
                        "mod" => ExprKind::Mod(x, y),
                        _ => unreachable!(
                            "Unexpected multiplicative operator {}", op
                        ),
                    }
                })
            },
        ))
    }

    fn expr_multiplicative_arg(
        input: ParseInput<'_>,
    ) -> ParseResult<(&str, Expr)> {
        Ok(match_nodes!(input.children();
            [expr_multiplicative_op(op), expr_over(e)] => (op, e)))
    }

    fn expr_multiplicative_op(input: ParseInput<'_>) -> ParseResult<&str> {
        Ok(input.as_str())
    }

    fn expr_over(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [expr_application(e)] => e,
            [expr_application(e1), _over(_), expr(e2)] => {
                ExprKind::Aggregate(Box::new(e1), Box::new(e2)).wrap(input)
            }
        ))
    }

    fn expr_application(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [expr_unary(exprs)..] => {
                fold(&exprs.collect(), |x, y| { ExprKind::Apply(x, y) })
            },
        ))
    }

    fn expr_unary(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [expr_unary_op(o).., expr_postfix(e)] => {
                let ops = o.collect::<Vec<Span>>();
                ops.iter().fold(e.clone(), |acc, op| {
                    let span = op.union(&acc.span);
                    ExprKind::Negate(Box::new(acc)).spanned(&span)
                })
            },
        ))
    }

    fn expr_unary_op(input: ParseInput) -> ParseResult<Span> {
        Ok(input_to_span(&input))
    }

    fn expr_postfix(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [atom(e), label(l)..] => {
                l.collect::<Vec<_>>().iter().fold(e.clone(), |acc, label| {
                    let selector =
                        ExprKind::RecordSelector(label.name.to_string())
                            .spanned(&label.span);
                    let span = acc.span.union(&label.span);
                    ExprKind::Apply(Box::new(selector), Box::new(acc))
                        .spanned(&span)
                })
            },
        ))
    }

    fn tuple_expr(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [expr(exprs)..] => {
                let expr_vec: Vec<_> = exprs.into_iter().collect();
                match expr_vec.len() {
                    0 => {
                        let literal = LiteralKind::Unit.wrap(input);
                        let span = literal.span.clone();
                        ExprKind::Literal(literal).spanned(&span)
                    },
                    1 => expr_vec[0].clone(),
                    _ => ExprKind::Tuple(expr_vec).wrap(input),
                }
            },
        ))
    }

    fn list_expr(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [expr(exprs)..] => {
                ExprKind::List(exprs.collect()).wrap(input)
            },
        ))
    }

    fn record_expr(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [] => {
                ExprKind::Record(None, vec![]).wrap(input)
            },
            [record_body(b)] => {
                ExprKind::Record(b.0, b.1).wrap(input)
            },
        ))
    }

    fn record_body(
        input: ParseInput,
    ) -> ParseResult<(Option<Box<Expr>>, Vec<LabeledExpr>)> {
        Ok(match_nodes!(input.children();
            [expr(e), _with(_), labeled_expr(exprs)..] => {
                (Some(Box::new(e)), exprs.collect())
            },
            [labeled_expr(exprs)..] => {
                (None, exprs.collect())
            },
        ))
    }

    fn labeled_expr(input: ParseInput) -> ParseResult<LabeledExpr> {
        Ok(match_nodes!(input.children();
            [label(l), expr(e)] => LabeledExpr::new(Some(l), &e),
            [expr(e)] => LabeledExpr::new(None, &e),
        ))
    }

    fn label(input: ParseInput) -> ParseResult<Label> {
        Ok(match_nodes!(input.children();
            [quoted_identifier(i)] => {
                Label::new(i.as_str(), &input_to_span(&input))
            },
            [unquoted_identifier(i)] => Label::new(i, &input_to_span(&input)),
            [non_negative_integer(i)] => Label::new(i, &input_to_span(&input)),
        ))
    }

    fn atom(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [literal(l)] => ExprKind::Literal(l).wrap(input),
            [identifier_expr(e)] => e,
            [record_selector(r)] => {
                ExprKind::RecordSelector(r.to_string()).wrap(input)
            },
            [_current(_)] => ExprKind::Current.wrap(input),
            [_ordinal(_)] => ExprKind::Ordinal.wrap(input),
            [tuple_expr(e)] => e,
            [list_expr(e)] => e,
            [record_expr(e)] => e,
            [if_expr(e)] => e,
            [case_expr(e)] => e,
            [let_expr(e)] => e,
            [fn_expr(e)] => e,
            [exists_expr(e)] => e,
            [from_expr(e)] => e,
            [forall_expr(e)] => e,
            [expr(e)] => e, // parenthesized expression; should re-wrap?
        ))
    }

    fn if_expr(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [_if(_), expr(cond), _then(_), expr(then_expr), _else(_),
             expr(else_expr)] => {
                ExprKind::If(
                    Box::new(cond),
                    Box::new(then_expr),
                    Box::new(else_expr),
                ).wrap(input)
            },
        ))
    }

    fn case_expr(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [_case(_), expr(e), _of(_), match_list(arms)] => {
                ExprKind::Case(Box::new(e), arms).wrap(input)
            },
        ))
    }

    fn let_expr(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [_let(_), decl_list(decls), _in(_), expr(e), _end(_)] => {
                ExprKind::Let(decls, Box::new(e)).wrap(input)
            },
        ))
    }

    fn decl_list(input: ParseInput) -> ParseResult<Vec<Decl>> {
        Ok(match_nodes!(input.children();
            [decl(decls)..] => decls.collect(),
        ))
    }

    fn fn_expr(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [_fn(_), match_list(matches)] => {
                ExprKind::Fn(matches).wrap(input)
            },
        ))
    }

    fn match_list(input: ParseInput) -> ParseResult<Vec<Match>> {
        Ok(match_nodes!(input.children();
            [match_(matches)..] => matches.collect(),
        ))
    }

    fn match_(input: ParseInput) -> ParseResult<Match> {
        Ok(match_nodes!(input.children();
            [pat(p), expr(e)] => {
                Match {pat: p, expr: e}
            },
        ))
    }

    fn from_expr(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [_from(_), scan_list(scans), step(s).., terminal_step(ts)] => {
                let steps =
                    scans.into_iter()
                        .chain(s.into_iter().flatten().collect::<Vec<_>>())
                        .chain([ts])
                        .collect();
                ExprKind::From(steps).wrap(input)
            },
            [_from(_), step(s).., terminal_step(ts)] => {
                let steps: Vec<Step> =
                    s.into_iter().flatten().chain([ts]).collect();
                ExprKind::From(steps).wrap(input)
            },
            [_from(_), scan_list(scans), step(s)..] => {
                let steps =
                    scans.into_iter().chain(s.into_iter().flatten()).collect();
                ExprKind::From(steps).wrap(input)
            },
            [_from(_), step(s)..] => {
                let steps = s.into_iter().flatten().collect();
                ExprKind::From(steps).wrap(input)
            },
        ))
    }

    fn exists_expr(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [_exists(_), scan_list(scans), step(s)..] => {
                let steps =
                    scans.into_iter()
                        .chain(s.into_iter().flatten().collect::<Vec<_>>())
                        .collect();
                ExprKind::Exists(steps).wrap(input)
            },
            [_exists(_), step(s)..] => {
                let steps = s.into_iter().flatten().collect();
                ExprKind::Exists(steps).wrap(input)
            },
        ))
    }

    fn forall_expr(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [_forall(_), scan_list(scans), step(s).., require(r)] => {
                let steps =
                    scans.into_iter()
                        .chain(s.into_iter().flatten().collect::<Vec<_>>())
                        .chain([r])
                        .collect();
                ExprKind::Forall(steps).wrap(input)
            },
            [_forall(_), step(s).., require(r)] => {
                let steps = s.into_iter().flatten().chain([r]).collect();
                ExprKind::Forall(steps).wrap(input)
            },
        ))
    }

    fn terminal_step(input: ParseInput) -> ParseResult<Step> {
        Ok(match_nodes!(input.children();
            [compute(s)] => s,
            [into_(s)] => s,
        ))
    }

    fn step(input: ParseInput) -> ParseResult<Vec<Step>> {
        Ok(match_nodes!(input.children();
            [_distinct(_)] => vec![StepKind::Distinct.wrap(input)],
            [except(s)] => vec![s],
            [group(s)] => vec![s],
            [intersect(s)] => vec![s],
            [join(steps)] => steps,
            [order(s)] => vec![s],
            [skip(s)] => vec![s],
            [take(s)] => vec![s],
            [through(s)] => vec![s],
            [union(s)] => vec![s],
            [_unorder(_)] => vec![StepKind::Unorder.wrap(input)],
            [where_(s)] => vec![s],
            [yield_(s)] => vec![s],
        ))
    }

    fn scan_list(input: ParseInput) -> ParseResult<Vec<Step>> {
        Ok(match_nodes!(input.children();
            [scan1(first), scan(rest)..] => {
                [first].into_iter().chain(rest).collect()
            },
        ))
    }

    fn scan1(input: ParseInput) -> ParseResult<Step> {
        Ok(match_nodes!(input.children();
            [scan1_eq(s)] => s,
            [scan1_in(s)] => s,
            [pat(p)] => StepKind::Join(Box::new(p)).wrap(input),
        ))
    }

    fn scan1_eq(input: ParseInput) -> ParseResult<Step> {
        Ok(match_nodes!(input.children();
            [pat(p), expr(e)] => {
                StepKind::JoinEq(Box::new(p), Box::new(e), None).wrap(input)
            },
        ))
    }

    fn scan1_in(input: ParseInput) -> ParseResult<Step> {
        Ok(match_nodes!(input.children();
            [pat(p), _in(_), expr(e)] => {
                StepKind::JoinIn(Box::new(p), Box::new(e), None).wrap(input)
            },
        ))
    }

    fn scan(input: ParseInput) -> ParseResult<Step> {
        Ok(match_nodes!(input.children();
            [scan_eq(s)] => s,
            [scan_in(s)] => s,
            [pat(p)] => StepKind::Join(Box::new(p)).wrap(input),
        ))
    }

    fn scan_eq(input: ParseInput) -> ParseResult<Step> {
        Ok(match_nodes!(input.children();
            [pat(p), expr(e), _on(_), expr(c)] => {
                StepKind::JoinEq(Box::new(p), Box::new(e), Some(Box::new(c)))
                    .wrap(input)
            },
            [pat(p), expr(e)] => {
                StepKind::JoinEq(Box::new(p), Box::new(e), None)
                    .wrap(input)
            },
        ))
    }

    fn scan_in(input: ParseInput) -> ParseResult<Step> {
        Ok(match_nodes!(input.children();
            [pat(p), _in(_), expr(e), _on(_), expr(c)] => {
                StepKind::JoinIn(Box::new(p), Box::new(e), Some(Box::new(c)))
                    .wrap(input)
            },
            [pat(p), _in(_), expr(e)] => {
                StepKind::JoinIn(Box::new(p), Box::new(e), None)
                    .wrap(input)
            },
        ))
    }

    fn join(input: ParseInput) -> ParseResult<Vec<Step>> {
        Ok(match_nodes!(input.children();
            [_join(_), scan(s)..] => s.collect(),
        ))
    }

    fn compute(input: ParseInput) -> ParseResult<Step> {
        Ok(match_nodes!(input.children();
            [_compute(_), expr(e)] => {
                StepKind::Compute(Box::new(e)).wrap(input)
            },
        ))
    }

    fn except(input: ParseInput) -> ParseResult<Step> {
        Ok(match_nodes!(input.children();
            [_except(_), _distinct(_), expr(exprs)..] => {
                StepKind::Except(true, exprs.collect()).wrap(input)
            },
            [_except(_), expr(exprs)..] => {
                StepKind::Except(false, exprs.collect()).wrap(input)
            },
        ))
    }

    fn group(input: ParseInput) -> ParseResult<Step> {
        Ok(match_nodes!(input.children();
            [_group(_), expr(e)] => {
                StepKind::Group(Box::new(e), None).wrap(input)
            },
            [_group(_), expr(e), _compute(_), expr(c)] => {
                StepKind::Group(Box::new(e), Some(Box::new(c))).wrap(input)
            },
        ))
    }

    fn order(input: ParseInput) -> ParseResult<Step> {
        Ok(match_nodes!(input.children();
            [_order(_), expr(e)] => {
                StepKind::Order(Box::new(e)).wrap(input)
            },
        ))
    }

    fn into_(input: ParseInput) -> ParseResult<Step> {
        Ok(match_nodes!(input.children();
            [_into(_), expr(e)] => {
                StepKind::Into(Box::new(e)).wrap(input)
            },
        ))
    }

    fn intersect(input: ParseInput) -> ParseResult<Step> {
        Ok(match_nodes!(input.children();
            [_intersect(_), _distinct(_), expr(exprs)..] => {
                StepKind::Intersect(true, exprs.collect()).wrap(input)
            },
            [_intersect(_), expr(exprs)..] => {
                StepKind::Intersect(false, exprs.collect()).wrap(input)
            },
        ))
    }

    fn require(input: ParseInput) -> ParseResult<Step> {
        Ok(match_nodes!(input.children();
            [_require(_), expr(e)] => {
                StepKind::Require(Box::new(e)).wrap(input)
            },
        ))
    }

    fn skip(input: ParseInput) -> ParseResult<Step> {
        Ok(match_nodes!(input.children();
            [_skip(_), expr(e)] => {
                StepKind::Skip(Box::new(e)).wrap(input)
            },
        ))
    }

    fn take(input: ParseInput) -> ParseResult<Step> {
        Ok(match_nodes!(input.children();
            [_take(_), expr(e)] => {
                StepKind::Take(Box::new(e)).wrap(input)
            },
        ))
    }

    fn through(input: ParseInput) -> ParseResult<Step> {
        Ok(match_nodes!(input.children();
            [_through(_), pat(p), _in(_), expr(e)] => {
                StepKind::Through(Box::new(p), Box::new(e)).wrap(input)
            },
        ))
    }

    fn union(input: ParseInput) -> ParseResult<Step> {
        Ok(match_nodes!(input.children();
            [_union(_), _distinct(_), expr(exprs)..] => {
                StepKind::Union(true, exprs.collect()).wrap(input)
            },
            [_union(_), expr(exprs)..] => {
                StepKind::Union(false, exprs.collect()).wrap(input)
            },
        ))
    }

    fn where_(input: ParseInput) -> ParseResult<Step> {
        Ok(match_nodes!(input.children();
            [_where(_), expr(e)] => {
                StepKind::Where(Box::new(e)).wrap(input)
            },
        ))
    }

    fn yield_(input: ParseInput) -> ParseResult<Step> {
        Ok(match_nodes!(input.children();
            [_yield(_), expr(e)] => {
                StepKind::Yield(Box::new(e)).wrap(input)
            },
        ))
    }

    fn pat(input: ParseInput) -> ParseResult<Pat> {
        Ok(match_nodes!(input.children();
            [annotated_pat(p)] => p,
        ))
    }

    fn annotated_pat(input: ParseInput) -> ParseResult<Pat> {
        Ok(match_nodes!(input.children();
            [cons_pat(p)] => p,
            [cons_pat(p), type_(t)] => {
                PatKind::Annotated(Box::new(p), Box::new(t)).wrap(input)
            },
        ))
    }

    fn cons_pat(input: ParseInput) -> ParseResult<Pat> {
        Ok(match_nodes!(input.children();
            [atomic_pat(p)] => p,
            [atomic_pat(p), cons_pat(c)] => {
                PatKind::Cons(Box::new(p), Box::new(c)).wrap(input)
            },
        ))
    }

    fn atomic_pat(input: ParseInput) -> ParseResult<Pat> {
        Ok(match_nodes!(input.children();
            [wildcard_pat(p)] => p,
            [constructor_pat(p)] => p,
            [as_pat(p)] => p,
            [id_pat(p)] => p,
            [literal_pat(p)] => p,
            [tuple_pat(p)] => p,
            [record_pat(p)] => p,
            [list_pat(p)] => p,
            [cons_pat(p)] => p,
            [pat(p)] => p,
        ))
    }

    fn wildcard_pat(input: ParseInput) -> ParseResult<Pat> {
        Ok(PatKind::Wildcard.spanned(&input_to_span(&input)))
    }

    fn id_pat(input: ParseInput) -> ParseResult<Pat> {
        Ok(match_nodes!(input.children();
            [identifier(i)] => PatKind::Identifier(i.to_string()).wrap(input),
        ))
    }

    fn as_pat(input: ParseInput) -> ParseResult<Pat> {
        Ok(match_nodes!(input.children();
            [identifier(i), _as(_), pat(p)] => {
                PatKind::As(i.to_string(), Box::new(p)).wrap(input)
            },
        ))
    }

    fn constructor_pat(input: ParseInput) -> ParseResult<Pat> {
        Ok(match_nodes!(input.children();
            [identifier(i), atomic_pat(p)] => {
                PatKind::Constructor(i.to_string(), Some(Box::new(p)))
                    .wrap(input)
            },
        ))
    }

    fn literal_pat(input: ParseInput) -> ParseResult<Pat> {
        Ok(match_nodes!(input.children();
            [literal(l)] => PatKind::Literal(l).spanned(&input_to_span(&input)),
        ))
    }

    fn tuple_pat(input: ParseInput) -> ParseResult<Pat> {
        Ok(match_nodes!(input.children();
            [pat(pats)..] => {
                PatKind::Tuple(pats.collect()).wrap(input)
            },
        ))
    }

    fn record_pat(input: ParseInput) -> ParseResult<Pat> {
        Ok(match_nodes!(input.children();
            [pat_field(fields)..] => {
                PatKind::Record(fields.collect(), false).wrap(input)
            },
            [pat_field(fields).., ellipsis(b)] => {
                PatKind::Record(fields.collect(), b).wrap(input)
            },
        ))
    }

    fn ellipsis(input: ParseInput) -> ParseResult<bool> {
        Ok(true)
    }

    fn pat_field(input: ParseInput) -> ParseResult<PatField> {
        Ok(match_nodes!(input.children();
            [anon_pat_field(f)] => f,
            [labeled_pat_field(f)] => f,
        ))
    }

    fn anon_pat_field(input: ParseInput) -> ParseResult<PatField> {
        Ok(match_nodes!(input.children();
            [pat(p)] => {
                let span = input_to_span(&input);
                PatField::Anonymous(span, p)
            },
        ))
    }

    fn labeled_pat_field(input: ParseInput) -> ParseResult<PatField> {
        Ok(match_nodes!(input.children();
            [identifier(i), pat(p)] => {
                let span = input_to_span(&input);
                PatField::Labeled(span, i.to_string(), p)
            },
        ))
    }

    fn list_pat(input: ParseInput) -> ParseResult<Pat> {
        Ok(match_nodes!(input.children();
            [pat(pats)..] => PatKind::List(pats.collect()).wrap(input),
        ))
    }

    fn decl(input: ParseInput) -> ParseResult<Decl> {
        Ok(match_nodes!(input.children();
            [val_decl(d)] => d.wrap(input),
            [fun_decl(d)] => d.wrap(input),
            [over_decl(d)] => d.wrap(input),
            [type_decl(d)] => d.wrap(input),
            [datatype_decl(d)] => d.wrap(input),
        ))
    }

    fn val_decl(input: ParseInput) -> ParseResult<DeclKind> {
        Ok(match_nodes!(input.children();
            [_val(_), _rec(_), val_bind(b), and_val_bind(rest)..] => {
                let mut binds = vec![b];
                binds.extend(rest.collect::<Vec<_>>());
                DeclKind::Val(true, false, binds)
            },
            [_val(_), val_bind(b), and_val_bind(rest)..] => {
                let mut binds = vec![b];
                binds.extend(rest.collect::<Vec<_>>());
                DeclKind::Val(false, false, binds)
            },
            [_val(_), _inst(_), _rec(_), val_bind(b), and_val_bind(rest)..] => {
                let mut binds = vec![b];
                binds.extend(rest.collect::<Vec<_>>());
                DeclKind::Val(true, true, binds)
            },
            [_val(_), _inst(_), val_bind(b), and_val_bind(rest)..] => {
                let mut binds = vec![b];
                binds.extend(rest.collect::<Vec<_>>());
                DeclKind::Val(false, true, binds)
            },
        ))
    }

    fn val_bind(input: ParseInput) -> ParseResult<ValBind> {
        Ok(match_nodes!(input.children();
            [pat(p), expr(e)] => ValBind::of(&p, None, &e),
            [pat(p), type_(t), expr(e)] => {
                ValBind::of(&p, Some(t), &e)
            },
        ))
    }

    fn and_val_bind(input: ParseInput) -> ParseResult<ValBind> {
        Ok(match_nodes!(input.children();
            [_and(_), val_bind(b)] => b,
        ))
    }

    fn fun_decl(input: ParseInput) -> ParseResult<DeclKind> {
        Ok(match_nodes!(input.children();
            [_fun(_), fun_bind(bind), and_fun_bind(rest)..] => {
                let mut binds = vec![bind];
                binds.extend(rest.collect::<Vec<_>>());
                DeclKind::Fun(binds)
            },
            [_fun(_), fun_bind(bind)] => DeclKind::Fun(vec![bind]),
        ))
    }

    fn and_fun_bind(input: ParseInput) -> ParseResult<FunBind> {
        Ok(match_nodes!(input.children();
            [_and(_), fun_bind(b)] => b,
        ))
    }

    fn fun_bind(input: ParseInput) -> ParseResult<FunBind> {
        Ok(match_nodes!(input.children();
            [fun_match(matches)..] => {
                let matches: Vec<_> = matches.collect();
                let name = matches[0].name.clone();
                let span = input_to_span(&input);
                FunBind {span, name, matches}
            }
        ))
    }

    fn fun_match(input: ParseInput) -> ParseResult<FunMatch> {
        Ok(match_nodes!(input.children();
            [identifier(i), pat(p).., type_(t), expr(e)] => {
                let name = i.to_string();
                let pats = p.collect::<Vec<_>>();
                let span = input_to_span(&input);
                let type_ = Some(Box::new(t));
                FunMatch {span, name, pats, type_, expr: e}
            },
            [identifier(i), pat(p).., expr(e)] => {
                let name = i.to_string();
                let pats = p.collect::<Vec<_>>();
                let span = input_to_span(&input);
                FunMatch {span, name, pats, type_: None, expr: e}
            },
        ))
    }

    fn over_decl(input: ParseInput) -> ParseResult<DeclKind> {
        Ok(match_nodes!(input.children();
            [_over(_), identifier(i)] => DeclKind::Over(i),
        ))
    }

    fn type_decl(input: ParseInput) -> ParseResult<DeclKind> {
        Ok(match_nodes!(input.children();
            [_type(_), type_bind(bind), _and(_), type_bind(rest)..] => {
                let mut binds = vec![bind];
                binds.extend(rest.collect::<Vec<_>>());
                DeclKind::Type(binds)
            },
            [_type(_), type_bind(bind)] => DeclKind::Type(vec![bind]),
        ))
    }

    fn type_bind(input: ParseInput) -> ParseResult<TypeBind> {
        Ok(match_nodes!(input.children();
            [identifier(i), type_(t)] => {
                let span = input_to_span(&input);
                let name = i.to_string();
                TypeBind {span, type_vars: vec![], name, type_: t}
            },
            [type_vars(vars), identifier(i), type_(t)] => {
                let span = input_to_span(&input);
                let name = i.to_string();
                TypeBind {span, type_vars: vars, name, type_: t}
            },
        ))
    }

    fn datatype_decl(input: ParseInput) -> ParseResult<DeclKind> {
        Ok(match_nodes!(input.children();
            [_datatype(_), datatype_bind(bind), _and(_),
             datatype_bind(rest)..] => {
                let mut binds = vec![bind];
                binds.extend(rest.collect::<Vec<_>>());
                DeclKind::Datatype(binds)
            },
            [_datatype(_), datatype_bind(bind)] => {
                DeclKind::Datatype(vec![bind])
            },
        ))
    }

    fn datatype_bind(input: ParseInput) -> ParseResult<DatatypeBind> {
        Ok(match_nodes!(input.children();
            [identifier(i), con_bind(cons)..] => {
                let span = input_to_span(&input);
                let name = i.to_string();
                let constructors = cons.collect();
                DatatypeBind {span, type_vars: vec![], name, constructors}
            },
            [type_vars(vars), identifier(i), con_bind(cons)..] => {
                let span = input_to_span(&input);
                let name = i.to_string();
                let constructors = cons.collect();
                DatatypeBind {span, type_vars: vars, name, constructors}
            },
        ))
    }

    fn con_bind(input: ParseInput) -> ParseResult<ConBind> {
        Ok(match_nodes!(input.children();
            [identifier(i)] => {
                let span = input_to_span(&input);
                ConBind {span, name: i.to_string(), type_: None}
            },
            [identifier(i), _of(_), type_(t)] => {
                let span = input_to_span(&input);
                ConBind {span, name: i.to_string(), type_: Some(t)}
            },
        ))
    }

    fn type_scheme_top(input: ParseInput) -> ParseResult<TypeScheme> {
        Ok(match_nodes!(input.children();
            [type_scheme(s), EOI(_)] => s,
        ))
    }

    fn type_scheme(input: ParseInput) -> ParseResult<TypeScheme> {
        Ok(match_nodes!(input.children();
            [type_(t)] => TypeScheme {var_count: 0, type_: t},
            [_forall(_), non_negative_integer(i), type_(t)] => {
                TypeScheme {var_count: i.parse().unwrap(), type_: t}
            },
        ))
    }

    fn type_(input: ParseInput) -> ParseResult<Type> {
        Ok(match_nodes!(input.children();
            [fn_type(t)] => t,
        ))
    }

    fn named_type(input: ParseInput) -> ParseResult<Type> {
        Ok(match_nodes!(input.children();
            [identifier(i)] => TypeKind::Id(i.to_string()).wrap(input),
        ))
    }

    fn fn_type(input: ParseInput) -> ParseResult<Type> {
        Ok(match_nodes!(input.children();
            [tuple_type(t)] => t,
            [tuple_type(t), fn_type(r)] => {
                TypeKind::Fn(Box::new(t), Box::new(r)).wrap(input)
            },
        ))
    }

    fn tuple_type(input: ParseInput) -> ParseResult<Type> {
        Ok(match_nodes!(input.children();
            [apply_type(t)] => t,
            [apply_type(t)..] => {
                TypeKind::Tuple(t.collect()).wrap(input)
            },
        ))
    }

    fn apply_type(input: ParseInput) -> ParseResult<Type> {
        Ok(match_nodes!(input.children();
            [atomic_type(t), named_type(types)..] => {
                let type_vec: Vec<_> = types.collect();
                if type_vec.is_empty() {
                    t.with_span(&input_to_span(&input))
                } else {
                    type_vec.iter().fold(
                        t,
                        |acc, t2| {
                            let span = acc.span.union(&t2.span);
                            let type_args = match &acc.kind {
                                TypeKind::Tuple(types) => types.clone(),
                                _ => vec![acc.clone()],
                            };
                        TypeKind::App(type_args, Box::new(t2.clone()))
                            .spanned(&span)
                    }
                )}
            },
        ))
    }

    fn atomic_type(input: ParseInput) -> ParseResult<Type> {
        Ok(match_nodes!(input.children();
            [named_type(t)] => t,
            [type_var(t)] => t,
            [type_con(t)] => t,
            [type_(t)] => t, // e.g. `(int)`, `(int * string list)`
            [record_type(t)] => t,
            [expression_type(t)] => t, // e.g. `typeof 1 + 2`
            [composite_type(t)] => t,
        ))
    }

    fn type_var(input: ParseInput) -> ParseResult<Type> {
        Ok(match_nodes!(input.children();
            [ty_var(i)] => TypeKind::Var(i.to_string()).wrap(input),
        ))
    }

    fn ty_var(input: ParseInput<'_>) -> ParseResult<&str> {
        Ok(input.as_str())
    }

    fn type_con(input: ParseInput) -> ParseResult<Type> {
        Ok(match_nodes!(input.children();
            [identifier(i)] => TypeKind::Con(i.to_string()).wrap(input),
        ))
    }

    fn record_type(input: ParseInput) -> ParseResult<Type> {
        Ok(match_nodes!(input.children();
            [type_field(tf)..] => {
                TypeKind::Record(tf.collect()).wrap(input)
            },
        ))
    }

    fn expression_type(input: ParseInput) -> ParseResult<Type> {
        Ok(match_nodes!(input.children();
            [_typeof(_), expr(e)] => {
                TypeKind::Expression(Box::new(e)).wrap(input)
            },
        ))
    }

    fn composite_type(input: ParseInput) -> ParseResult<Type> {
        Ok(match_nodes!(input.children();
            [type_(t)..] => {
                let types: Vec<Type> = t.collect();
                match types.len() {
                    0 => TypeKind::Unit.wrap(input),
                    1 => types[0].with_span(&input_to_span(&input)),
                    _ => TypeKind::Tuple(types).wrap(input),
                }
            },
        ))
    }

    fn type_field(input: ParseInput) -> ParseResult<TypeField> {
        Ok(match_nodes!(input.children();
            [label(l), type_(t)] => TypeField {label: l, type_: t},
        ))
    }

    fn type_vars(input: ParseInput) -> ParseResult<Vec<String>> {
        Ok(match_nodes!(input.children();
            [type_var(vars)..] => {
                vars.map(|t| match t.kind {
                    TypeKind::Var(v) => v,
                    _ => "".to_string()
                }).collect()
            },
        ))
    }

    fn literal(input: ParseInput) -> ParseResult<Literal> {
        Ok(match_nodes!(input.children();
            [numeric_literal(n)] => n,
            [string_literal(s)] => s,
            [char_literal(c)] => c,
            [bool_literal(b)] => b,
        ))
    }

    fn numeric_literal(input: ParseInput) -> ParseResult<Literal> {
        Ok(match_nodes!(input.children();
            [scientific_literal(n)] => n,
            [real_literal(n)] => n,
            [negative_integer_literal(n)] => n,
            [non_negative_integer_literal(n)] => n,
        ))
    }

    fn non_negative_integer(input: ParseInput<'_>) -> ParseResult<&str> {
        Ok(input.as_str())
    }

    fn non_negative_integer_literal(input: ParseInput) -> ParseResult<Literal> {
        let value = String::from(input.as_str());
        Ok(LiteralKind::Int(value).spanned(&input_to_span(&input)))
    }

    fn negative_integer_literal(input: ParseInput) -> ParseResult<Literal> {
        let value = String::from(input.as_str());
        Ok(LiteralKind::Int(value).spanned(&input_to_span(&input)))
    }

    fn real_literal(input: ParseInput) -> ParseResult<Literal> {
        let value = String::from(input.as_str());
        Ok(LiteralKind::Real(value).spanned(&input_to_span(&input)))
    }

    fn scientific_literal(input: ParseInput) -> ParseResult<Literal> {
        let value = String::from(input.as_str());
        Ok(LiteralKind::Real(value).spanned(&input_to_span(&input)))
    }

    fn string_literal(input: ParseInput) -> ParseResult<Literal> {
        let s = input.as_str().to_string();
        Ok(LiteralKind::String(s).spanned(&input_to_span(&input)))
    }

    fn char_literal(input: ParseInput) -> ParseResult<Literal> {
        let s = input.as_str().to_string();
        Ok(LiteralKind::Char(s).spanned(&input_to_span(&input)))
    }

    fn bool_literal(input: ParseInput) -> ParseResult<Literal> {
        let value = input.as_str() == "true";
        Ok(LiteralKind::Bool(value).spanned(&input_to_span(&input)))
    }

    fn identifier_expr(input: ParseInput) -> ParseResult<Expr> {
        Ok(match_nodes!(input.children();
            [identifier(i)] => ExprKind::Identifier(i.to_string()).wrap(input),
        ))
    }

    fn identifier(input: ParseInput) -> ParseResult<String> {
        Ok(match_nodes!(input.children();
            [quoted_identifier(i)] => i,
            [unquoted_identifier(i)] => i.to_string(),
        ))
    }

    fn unquoted_identifier(input: ParseInput<'_>) -> ParseResult<&str> {
        Ok(input.as_str())
    }

    fn quoted_identifier(input: ParseInput) -> ParseResult<String> {
        let s = input.as_str();
        Ok(s[1..s.len() - 1].replace("``", "`"))
    }

    fn record_selector(input: ParseInput<'_>) -> ParseResult<&str> {
        Ok(input.as_str())
    }

    fn EOI(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _and(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _andalso(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _as(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _case(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _compute(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _current(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _datatype(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _distinct(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _div(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _elem(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _else(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _end(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _except(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _exists(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _fn(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _forall(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _from(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _fun(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _group(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _if(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _implies(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _in(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _inst(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _intersect(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _into(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _join(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _let(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _mod(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _notelem(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _o(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _of(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _on(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _order(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _ordinal(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _orelse(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _over(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _rec(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _require(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _skip(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _take(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _then(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _through(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _type(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _typeof(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _union(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _unorder(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _val(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _where(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _with(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn _yield(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }
}

/// Combines a list of expressions using a binary function `f`.
///
/// For example, `bar(a, [b, c], f)` produces `f(f(a, b), c)`.
#[allow(clippy::ptr_arg)]
fn fold(
    exprs: &Vec<Expr>,
    f: impl Fn(Box<Expr>, Box<Expr>) -> ExprKind<Expr>,
) -> Expr {
    let mut rest = exprs.iter();
    let first = rest.next().unwrap();
    rest.fold(first.clone(), |acc, e| {
        let span = acc.span.union(&e.span);
        f(Box::new(acc), Box::new(e.clone())).spanned(&span)
    })
}

/// Combines expressions using a binary function, taking the first element
/// separately.
#[allow(clippy::ptr_arg)]
fn fold2(
    first: &Expr,
    exprs: &Vec<Expr>,
    f: impl Fn(Box<Expr>, Box<Expr>) -> ExprKind<Expr>,
) -> Expr {
    exprs.iter().fold(first.clone(), |acc, e| {
        let span = acc.span.union(&e.span);
        f(Box::new(acc), Box::new(e.clone())).spanned(&span)
    })
}

/// Combines expressions using a binary function with (operator, expression)
/// pairs.
fn fold_heterogeneous(
    first: &Expr,
    args: &Vec<(&str, Expr)>,
    f: impl Fn(&str, Box<Expr>, Box<Expr>) -> ExprKind<Expr>,
) -> Expr {
    args.iter().fold(first.clone(), |acc, op_arg| {
        let (op, e) = op_arg;
        let span = acc.span.union(&e.span);
        f(op, Box::new(acc), Box::new(e.clone())).spanned(&span)
    })
}

/// Given quoted identifier `abc` returns abc. Converts any
/// doubled back-ticks to a single back-tick. Assumes there are no single
/// back-ticks.
pub fn unquote_identifier(s: &str) -> Result<String, &'static str> {
    if s.len() < 2 {
        return Err("String must be at least 2 characters long");
    }
    if !s.starts_with('`') || !s.ends_with('`') {
        return Err("String must be enclosed in back-ticks");
    }

    let inner = &s[1..s.len() - 1];
    Ok(inner.replace("``", "`"))
}

/// Given quoted string "abc" returns abc; "\t" returns
/// the tab character; "\^A" returns character 1; "\255"
/// returns character 255.
pub fn unquote_string(s: &str) -> Result<String, String> {
    if s.len() < 2 {
        return Err("String must be at least 2 characters long".to_string());
    }
    if !s.starts_with('"') || !s.ends_with('"') {
        return Err("String must be enclosed in double quotes".to_string());
    }

    let inner = &s[1..s.len() - 1];
    if !inner.contains('\\') {
        // There are no escaped characters. Take the quick route.
        return Ok(inner.to_string());
    }

    let mut parser = StringParser::new(inner);
    let mut result = String::new();

    while parser.i < parser.s.len() {
        match parser.parse_char() {
            Ok(c) => result.push(c),
            Err(e) => return Err(e),
        }
    }
    Ok(result)
}

/// Given quoted char literal #"a" returns a.
pub fn unquote_char_literal(s: &str) -> Result<char, String> {
    assert!(s.len() >= 3);
    assert!(s.starts_with('#'));
    assert!(s.ends_with('"'));

    let inner = &s[2..s.len() - 1];
    let mut parser = StringParser::new(inner);
    let c = parser.parse_char()?;

    if parser.i != inner.len() {
        return Err("Error: character literal not length 1".to_string());
    }
    Ok(c)
}

/// Given string "a" returns a.
pub fn from_string(s: &str) -> Option<char> {
    if s.is_empty() {
        return None;
    }
    let mut parser = StringParser::new(s);
    parser.parse_char().ok()
}

/// Converts a character to how it appears in a character literal.
///
/// For example, 'a' becomes '"a"' and therefore `char_to_string('a')`
/// returns "a". Character 0 becomes "\\^@".
/// Character 255 becomes "\\255". Character 9 becomes "\t".
///
/// Inverse of `unquote_char_literal`.
pub fn char_to_string(c: char) -> String {
    match c as u8 {
        7 => "\\a".to_string(),   // Alert (ASCII 0x07)
        8 => "\\b".to_string(),   // Backspace (ASCII 0x08)
        9 => "\\t".to_string(),   // Horizontal tab (ASCII 0x09)
        10 => "\\n".to_string(),  // Linefeed or newline (ASCII 0x0A)
        11 => "\\v".to_string(),  // Vertical tab (ASCII 0x0B)
        12 => "\\f".to_string(),  // Form feed (ASCII 0x0C)
        13 => "\\r".to_string(),  // Carriage return (ASCII 0x0D)
        34 => "\\\"".to_string(), // Double-quote requires escape
        92 => "\\\\".to_string(), // Backslash requires escape
        n if n < 32 => {
            // chr(0) = "\\^@", chr(1) = "\\^A", ..., chr(31) = "\\^_"
            format!("\\^{}", (n + 64) as char)
        }
        n if n >= 127 => {
            format!("\\{}", n)
        }
        _ => c.to_string(),
    }
}

/// Converts an internal string to a string using Standard ML escapes,
/// appending to a string.
pub fn string_to_string_append(s: &str, buf: &mut String) {
    for c in s.chars() {
        buf.push_str(&char_to_string(c));
    }
}

/// Converts an internal string to a string using Standard ML escapes.
pub fn string_to_string(s: &str) -> String {
    if !requires_escape(s) {
        return s.to_string();
    }
    let mut result = String::new();
    string_to_string_append(s, &mut result);
    result
}

fn requires_escape(s: &str) -> bool {
    s.chars().any(|c| {
        let code = c as u32;
        code < 32 || c == '"' || c == '\\' || code > 127
    })
}

/// Appends an identifier. Encloses it in back-ticks if necessary.
pub fn append_id(buf: &mut String, id: &str) {
    if id.contains('`') {
        buf.push('`');
        buf.push_str(&id.replace('`', "``"));
        buf.push('`');
    } else if id.contains(' ') {
        buf.push('`');
        buf.push_str(id);
        buf.push('`');
    } else {
        buf.push_str(id);
    }
}

struct StringParser<'a> {
    s: &'a str,
    i: usize,
}

impl<'a> StringParser<'a> {
    fn new(s: &'a str) -> Self {
        StringParser { s, i: 0 }
    }

    /// Parses a single character in a string literal or character literal.
    /// Advances i to the next character in the string.
    fn parse_char(&mut self) -> Result<char, String> {
        if self.i >= self.s.len() {
            return Err("Unexpected end of string".to_string());
        }

        let chars: Vec<char> = self.s.chars().collect();
        let c = chars[self.i];
        self.i += 1;

        if c != '\\' {
            return Ok(c);
        }

        if self.i >= chars.len() {
            return Err("illegal escape; no character after \\".to_string());
        }

        let c2 = chars[self.i];
        self.i += 1;

        match c2 {
            '"' | '\\' => Ok(c2),
            'a' => Ok('\u{0007}'), // Alert (ASCII 0x07)
            'b' => Ok('\u{0008}'), // Backspace (ASCII 0x08)
            't' => Ok('\t'),       // Horizontal tab (ASCII 0x09)
            'n' => Ok('\n'),       // Linefeed or newline (ASCII 0x0A)
            'v' => Ok('\u{000B}'), // Vertical tab (ASCII 0x0B)
            'f' => Ok('\u{000C}'), // Form feed (ASCII 0x0C)
            'r' => Ok('\r'),       // Carriage return (ASCII 0x0D)
            '0'..='9' => {
                if self.i + 2 <= chars.len() {
                    let c3 = chars[self.i];
                    let c4 = chars[self.i + 1];
                    if c3.is_ascii_digit() && c4.is_ascii_digit() {
                        self.i += 2;
                        let d2 = (c2 as u8 - b'0') as u32;
                        let d3 = (c3 as u8 - b'0') as u32;
                        let d4 = (c4 as u8 - b'0') as u32;
                        let code = d2 * 100 + d3 * 10 + d4;
                        if code <= 255 {
                            return Ok(code as u8 as char);
                        }
                    }
                }
                Err("illegal control escape; invalid digits".to_string())
            }
            '^' => {
                if self.i >= chars.len() {
                    return Err("illegal control escape; no character after ^"
                        .to_string());
                }
                let c3 = chars[self.i];
                self.i += 1;
                if ('@'..='_').contains(&c3) {
                    // Characters "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"
                    // are contiguous.
                    Ok((c3 as u8 - b'@') as char)
                } else {
                    Err(concat!(
                        "illegal control escape; must be one of ",
                        "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"
                    )
                    .to_string())
                }
            }
            _ => Err("illegal escape; invalid character after \\".to_string()),
        }
    }
}

#[cfg(test)]
mod test {
    use crate::syntax::parser::{
        Rule, append_id, char_to_string, parse_unadorned_statement,
        unquote_identifier, unquote_string,
    };

    /// Test fixture for parser tests.
    struct Fixture {
        s: String,
    }

    impl Fixture {
        fn assert_statement(&self, matcher: impl Fn(&str)) {
            let expr = parse_unadorned_statement(self.s.as_str())
                .expect("parse should succeed");
            let s = format!("{}", expr.kind);
            matcher(&s);
        }

        fn fail(&self) {
            use super::MorelParser;
            use pest::Parser;

            let result = MorelParser::parse(Rule::literal, self.s.as_str());
            assert!(
                result.is_err(),
                "For [{}], expected parse to fail, got: {:?}",
                self.s,
                result
            );
        }

        pub(crate) fn assert_parse(&self, rule: Rule) {
            let v = vec![self.s.as_str()];
            self.assert_parse_as(rule, v.as_ref())
        }

        pub(crate) fn assert_parse_as(&self, rule: Rule, expected: &[&str]) {
            use super::MorelParser;
            use pest::Parser;

            let result = MorelParser::parse(rule, self.s.as_str());
            let file = result.expect("parse should succeed").next().unwrap();
            let mut actuals: Vec<String> = vec![];
            for line in file.into_inner() {
                actuals.push(line.as_str().to_string());
            }
            assert!(
                expected.eq(&actuals),
                "For [{}], expected parse to yield {:?}, got {:?}",
                self.s,
                expected,
                actuals
            );
        }

        pub(crate) fn assert_parse_tree(&self, rule: Rule, expected: &str) {
            use super::MorelParser;
            use pest::Parser;

            let result = MorelParser::parse(rule, self.s.as_str());
            let actual = pest_ascii_tree::into_ascii_tree(result.unwrap());
            assert_eq!(expected.to_string(), actual.unwrap());
        }
    }

    /// Creates a test fixture with the given code.
    fn ml(s: &str) -> Fixture {
        Fixture { s: s.to_string() }
    }

    /// Creates a matcher that asserts the string equals the expected value.
    fn is(expected: &str) -> impl Fn(&str) {
        move |actual: &str| {
            assert_eq!(
                actual, expected,
                "Expected string [{}], got [{}]",
                expected, actual
            );
        }
    }

    #[test]
    fn test_parse_literal() {
        ml("1").assert_parse(Rule::literal);
        ml("1").assert_parse_tree(
            Rule::numeric_literal,
            r#" numeric_literal
 └─ non_negative_integer_literal "1"
"#,
        );
        // We want "~1" to be parsed as an int literal, not unary "~" applied
        // to a literal.
        ml("~1").assert_parse_tree(
            Rule::expr_over,
            r#" expr_over
 └─ expr_application
    └─ expr_unary
       └─ expr_postfix
          └─ atom
             └─ literal
                └─ numeric_literal
                   └─ negative_integer_literal "~1"
"#,
        );
        ml("~3.5").assert_parse(Rule::literal);
        ml("~3.5").assert_parse_tree(
            Rule::numeric_literal,
            r#" numeric_literal
 └─ real_literal "~3.5"
"#,
        );
        // We want "~3.5" to be parsed as a real literal, not unary "~" applied
        // to a literal.
        ml("~3.5").assert_parse_tree(
            Rule::expr_over,
            r#" expr_over
 └─ expr_application
    └─ expr_unary
       └─ expr_postfix
          └─ atom
             └─ literal
                └─ numeric_literal
                   └─ real_literal "~3.5"
"#,
        );
        ml("~6.02e~23").assert_parse_tree(
            Rule::numeric_literal,
            r#" numeric_literal
 └─ scientific_literal "~6.02e~23"
"#,
        );
        ml("\"a string\"").assert_parse(Rule::literal);
        ml("\"\"").assert_parse(Rule::literal);
        ml("\"a\\\\b\\\"c\"").assert_parse(Rule::literal);
        ml("#\"a\"").assert_parse(Rule::literal);
        ml("#\"\\\"\"").assert_parse(Rule::literal);
        ml("#\"\\\\\"").assert_parse(Rule::literal);
        ml("123.45").assert_parse(Rule::literal);
        ml("\"a string\"").assert_parse(Rule::literal);
        ml("#\"a\"").assert_parse(Rule::literal);
        ml("not a number").fail();
    }

    #[test]
    fn test_parse_expr() {
        ml("fn {f: unit -> int, g: int} => true").assert_parse_tree(
            Rule::expr,
            r#" expr
 └─ expr_annotated
    └─ expr_implies
       └─ expr_orelse
          └─ expr_andalso
             └─ expr_o
                └─ expr_comp
                   └─ expr_cons
                      └─ expr_additive
                         └─ expr_multiplicative
                            └─ expr_over
                               └─ expr_application
                                  └─ expr_unary
                                     └─ expr_postfix
                                        └─ atom
                                           └─ fn_expr
                                              ├─ _fn "fn"
                                              └─ match_list
                                                 └─ match_
                                                    ├─ pat
                                                    │  └─ annotated_pat
                                                    │     └─ cons_pat
                                                    │        └─ atomic_pat
                                                    │           └─ record_pat
                                                    │              ├─ pat_field
                                                    │              │  └─ anon_pat_field
                                                    │              │     └─ pat
                                                    │              │        └─ annotated_pat
                                                    │              │           ├─ cons_pat
                                                    │              │           │  └─ atomic_pat
                                                    │              │           │     └─ id_pat
                                                    │              │           │        └─ identifier
                                                    │              │           │           └─ unquoted_identifier "f"
                                                    │              │           └─ type_
                                                    │              │              └─ fn_type
                                                    │              │                 ├─ tuple_type
                                                    │              │                 │  └─ apply_type
                                                    │              │                 │     └─ atomic_type
                                                    │              │                 │        └─ named_type
                                                    │              │                 │           └─ identifier
                                                    │              │                 │              └─ unquoted_identifier "unit"
                                                    │              │                 └─ fn_type
                                                    │              │                    └─ tuple_type
                                                    │              │                       └─ apply_type
                                                    │              │                          └─ atomic_type
                                                    │              │                             └─ named_type
                                                    │              │                                └─ identifier
                                                    │              │                                   └─ unquoted_identifier "int"
                                                    │              └─ pat_field
                                                    │                 └─ anon_pat_field
                                                    │                    └─ pat
                                                    │                       └─ annotated_pat
                                                    │                          ├─ cons_pat
                                                    │                          │  └─ atomic_pat
                                                    │                          │     └─ id_pat
                                                    │                          │        └─ identifier
                                                    │                          │           └─ unquoted_identifier "g"
                                                    │                          └─ type_
                                                    │                             └─ fn_type
                                                    │                                └─ tuple_type
                                                    │                                   └─ apply_type
                                                    │                                      └─ atomic_type
                                                    │                                         └─ named_type
                                                    │                                            └─ identifier
                                                    │                                               └─ unquoted_identifier "int"
                                                    └─ expr
                                                       └─ expr_annotated
                                                          └─ expr_implies
                                                             └─ expr_orelse
                                                                └─ expr_andalso
                                                                   └─ expr_o
                                                                      └─ expr_comp
                                                                         └─ expr_cons
                                                                            └─ expr_additive
                                                                               └─ expr_multiplicative
                                                                                  └─ expr_over
                                                                                     └─ expr_application
                                                                                        └─ expr_unary
                                                                                           └─ expr_postfix
                                                                                              └─ atom
                                                                                                 └─ literal
                                                                                                    └─ bool_literal "true"
"#,
        );
    }

    #[test]
    fn test_parse_comment() {
        let vec1 = vec!["1;", ""];
        ml("(* block comment *)  1;").assert_parse_as(Rule::program, &vec1);
        ml("(*\n * block comment\n *)\n1;")
            .assert_parse_as(Rule::program, &vec1);
        ml("(*) line comment\n1;").assert_parse_as(Rule::program, &vec1);
        ml("1; (* comment *)").assert_parse_as(Rule::program, &vec1);
    }

    #[test]
    fn test_parse_decl() {
        ml("1").assert_parse(Rule::expr);
        ml("xyz").assert_parse(Rule::expr);
        ml("xyz").assert_parse(Rule::statement);
        ml("val x = 5").assert_parse(Rule::statement);
        ml("val `x` = 5").assert_parse(Rule::statement);
    }

    #[test]
    fn test_parse_type() {
        ml("int").assert_parse(Rule::type_);
        ml("int * int").assert_parse(Rule::type_);
        ml("int * int list").assert_parse(Rule::type_);
        ml("(int * int) list").assert_parse(Rule::type_);
        ml("int * (int list)").assert_parse(Rule::type_);
        ml("{a: int, b: bool list}").assert_parse(Rule::type_);
        ml("int * int -> bool").assert_parse(Rule::type_);

        let v = vec!["forall 2 int * int -> bool", ""];
        ml("forall 2 int * int -> bool")
            .assert_parse_as(Rule::type_scheme_top, v.as_ref());

        let v2 = vec!["int * bool list", ""];
        ml("int * bool list")
            .assert_parse_as(Rule::type_scheme_top, v2.as_ref());
    }

    #[test]
    fn test_parse_build() {
        // ml("1").assert_statement(&is("1"));
        ml("val x = 5").assert_statement(&is("val x = 5"));
    }

    #[test]
    fn test_unquote_identifier() {
        assert_eq!(unquote_identifier("`abc`").unwrap(), "abc");
        assert_eq!(unquote_identifier("`a``b`").unwrap(), "a`b");
        assert!(unquote_identifier("abc").is_err());
        assert!(unquote_identifier("`").is_err());
    }

    #[test]
    fn test_unquote_string() {
        assert_eq!(unquote_string("\"abc\"").unwrap(), "abc");
        assert_eq!(unquote_string("\"\\t\"").unwrap(), "\t");
        assert_eq!(unquote_string("\"\\^A\"").unwrap(), "\u{0001}");
    }

    #[test]
    fn test_char_to_string() {
        assert_eq!(char_to_string('a'), "a");
        assert_eq!(char_to_string('\t'), "\\t");
        assert_eq!(char_to_string('\u{0001}'), "\\^A");
    }

    #[test]
    fn test_append_id() {
        let mut buf = String::new();
        append_id(&mut buf, "simple");
        assert_eq!(buf, "simple");

        buf.clear();
        append_id(&mut buf, "with space");
        assert_eq!(buf, "`with space`");

        buf.clear();
        append_id(&mut buf, "with`tick");
        assert_eq!(buf, "`with``tick`");
    }
}
