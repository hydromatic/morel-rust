// Licensed to Julian Hyde under one or more contributor license
// agreements.  See the NOTICE file distributed with this work
// for additional information regarding copyright ownership.
// Julian Hyde licenses this file to you under the Apache
// License, Version 2.0 (the "License"); you may not use this
// file except in compliance with the License.  You may obtain a
// copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
// either express or implied.  See the License for the specific
// language governing permissions and limitations under the
// License.

use crate::syntax::ast;
use crate::syntax::ast::{DeclKind, ExprKind, Span, UnspannedExpr};
use pest_consume::match_nodes;
use pest_consume::Parser;
use std::rc::Rc;

type ParseInput<'input> = pest_consume::Node<'input, Rule, Rc<str>>;

pub type ParseError = pest::error::Error<Rule>;
pub type ParseResult<T> = Result<T, ParseError>;

/// A syntax for the Morel language generated by Pest.
#[derive(Parser)]
#[grammar = "src/syntax/morel.pest"]
pub struct MorelParser;

pub fn parse(input: &str) -> ParseResult<ast::Statement> {
    let rc_input_str = input.to_string().into();
    let nodes =
        MorelParser::parse_with_userdata(Rule::statement, input, rc_input_str)?;
    Ok(match_nodes!(<MorelParser>; nodes;
        [statement(e)] => e,
    ))
}

fn input_to_span(input: ParseInput) -> Span {
    Span::make(input.user_data().clone(), input.as_pair().as_span())
}

fn spanned<E>(input: ParseInput, x: UnspannedExpr) -> ast::Expr {
    ast::Expr::of(input_to_span(input), x)
}

fn spanned_union<E>(span1: Span, span2: Span, x: UnspannedExpr) -> ast::Expr {
    ast::Expr::of(span1.union(&span2), x)
}

// #[pest_consume::parser(parser = MorelParser, rule = Rule)]
#[pest_consume::parser(parser = MorelParser)]
impl MorelParser {
    fn EOI(_input: ParseInput) -> ParseResult<()> {
        Ok(())
    }

    fn statement(input: ParseInput) -> ParseResult<ast::Statement> {
        Ok(match_nodes!(input.children();
            [expr(e)] => e.to_statement(input_to_span(input)),
            [decl(d)] => d.to_statement(input_to_span(input)),
        ))
    }

    fn expr(input: ParseInput) -> ParseResult<UnspannedExpr> {
        Ok(match_nodes!(input.children();
            [val_decl(d)] => todo!(),
        ))
    }

    fn expr_annotated(input: ParseInput) -> ParseResult<UnspannedExpr> {
        Ok(match_nodes!(input.children();
            [val_decl(d)] => todo!(),
        ))
    }

    fn decl(input: ParseInput) -> ParseResult<DeclKind> {
        Ok(match_nodes!(input.children();
            [val_decl(d)] => todo!(),
        ))
    }

    fn val_decl(input: ParseInput) -> ParseResult<DeclKind> {
        todo!()
    }

    fn literal(input: ParseInput) -> ParseResult<ast::Expr> {
        todo!()
    }

}

#[cfg(test)]
mod test {
    use crate::syntax::ast;
    use crate::syntax::ast::MorelNode;
    use crate::syntax::parser::Rule;
    use pest::iterators::Pair;
    use pest::Parser;

    /// Test fixture.
    struct Fixture {
        s: String,
    }

    impl Fixture {
        fn assert_build(&self, matcher: impl Fn(&str)) {
            use super::MorelParser;

            let result = MorelParser::parse(Rule::statement, self.s.as_str());
            let expr = ast::build_statement(
                result.expect("should parse").next().unwrap(),
            );
            let mut s = String::new();
            expr.unparse(&mut s);
            matcher(&s);
        }
    }

    impl Fixture {
        pub(crate) fn fail(&self) {
            use super::MorelParser;
            use pest::Parser;

            let result = MorelParser::parse(Rule::literal, self.s.as_str());
            assert!(
                result.is_err(),
                "For [{}], expected parse to fail, got: {:?}",
                self.s,
                result
            );
        }

        pub(crate) fn assert_parse(&self, rule: Rule) {
            self.assert_parse_as(rule, self.s.as_str())
        }

        pub(crate) fn assert_parse_as(&self, rule: Rule, expected: &str) {
            use super::MorelParser;
            use pest::Parser;

            let result = MorelParser::parse(rule, self.s.as_str());
            let file = result.expect("parse should succeed").next().unwrap();
            let matcher = &has_str(is(expected));
            let mut count = 0;
            for line in file.into_inner() {
                matcher(&line);
                count = count + 1;
            }
            assert_eq!(
                count, 1,
                "Expected exactly one match for [{}], got [{}]",
                self.s, count
            );
        }
    }

    /// Creates a fixture with a given piece of code.
    fn ml(s: &str) -> Fixture {
        Fixture { s: s.to_string() }
    }

    /// Creates a matcher that asserts the string is equal to `expected`.
    fn is(expected: &str) -> impl Fn(&str) {
        move |actual: &str| {
            assert_eq!(
                actual, expected,
                "Expected string [{}], got [{}]",
                expected, actual
            );
        }
    }

    /// Creates a matcher that asserts a line is of a given syntactic type and
    /// matches a given string.
    fn has_rule_str(
        rule_matcher: impl Fn(Rule),
        matcher: impl Fn(&str),
    ) -> impl Fn(&Pair<Rule>) {
        move |line: &Pair<Rule>| {
            rule_matcher(line.as_rule());
            matcher(line.as_str());
        }
    }

    fn has_str(matcher: impl Fn(&str)) -> impl Fn(&Pair<Rule>) {
        move |line: &Pair<Rule>| {
            matcher(line.as_str());
        }
    }

    /// Creates a matcher that asserts a line is of a given syntactic type and
    /// matches a given string.
    fn is_a(rule: Rule, matcher: impl Fn(&str)) -> impl Fn(&Pair<Rule>) {
        move |line: &Pair<Rule>| {
            assert_eq!(
                rule,
                line.as_rule(),
                "Expected rule {:?}, got {:?} for line [{}]",
                rule,
                line.as_rule(),
                line.as_str()
            );
            matcher(line.as_str());
        }
    }

    /// Creates a matcher that asserts a line has a given rule.
    fn is_rule(rule: Rule) -> impl Fn(&Pair<Rule>) {
        move |line: &Pair<Rule>| {
            assert_eq!(
                rule,
                line.as_rule(),
                "Expected rule {:?}, got {:?} for line [{}]",
                rule,
                line.as_rule(),
                line.as_str()
            );
        }
    }

    #[test]
    fn test_parse() {
        ml("1").assert_parse(Rule::literal);
        ml("~3.5").assert_parse(Rule::literal);
        ml("\"a string\"").assert_parse(Rule::literal);
        ml("\"\"").assert_parse(Rule::literal);
        ml("\"a\\\\b\\\"c\"").assert_parse(Rule::literal);
        ml("#\"a\"").assert_parse(Rule::literal);
        ml("#\"\\\"\"").assert_parse(Rule::literal);
        ml("#\"\\\\\"").assert_parse(Rule::literal);
        ml("123.45").assert_parse(Rule::literal);
        ml("\"a string\"").assert_parse(Rule::literal);
        ml("#\"a\"").assert_parse(Rule::literal);
        ml("not a number").fail();
        ml("(* block comment *)  1;")
            .assert_parse(Rule::statement_semicolon_list);
        ml("(*\n * block comment\n *)\n1;")
            .assert_parse(Rule::statement_semicolon_list);
        ml("(*) line comment\n1;").assert_parse(Rule::statement_semicolon_list);
        ml("1; (* comment *)")
            .assert_parse_as(Rule::statement_semicolon_list, "1;");
    }

    #[test]
    fn test_parse_decl() {
        ml("1").assert_parse(Rule::expr);
        ml("xyz").assert_parse(Rule::expr);
        ml("xyz").assert_parse(Rule::statement);
        ml("val x = 5").assert_parse(Rule::statement);
        ml("val `x` = 5").assert_parse(Rule::statement);
    }

    #[test]
    fn test_parse_build() {
        ml("1").assert_build(&is("1"));
        ml("val x = 5").assert_build(&is("val x = 5"));
    }
}
