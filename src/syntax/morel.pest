// Licensed to Julian Hyde under one or more contributor license
// agreements.  See the NOTICE file distributed with this work
// for additional information regarding copyright ownership.
// Julian Hyde licenses this file to you under the Apache
// License, Version 2.0 (the "License"); you may not use this
// file except in compliance with the License.  You may obtain a
// copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
// either express or implied.  See the License for the specific
// language governing permissions and limitations under the
// License.

// Whitespace and comments
WHITESPACE = _{ " " | NEWLINE }
COMMENT = _{ line_comment | block_comment }
line_comment = _{ "(*)" ~ (!NEWLINE ~ ANY)* ~ (NEWLINE | EOI) }
block_comment = _{ "(*" ~ (block_comment | (!"*)" ~ ANY))* ~ "*)" }

// Keywords
keywords = {
    "and" | "andalso" | "as" | "case" | "datatype" | "div" | "else" | "end" |
    "fn" | "fun" | "if" | "in" | "let" | "mod" | "o" | "of" | "orelse" |
    "rec" | "then" | "type" | "val" |
    // Relational extensions
    "compute" | "current" | "distinct" | "elem" | "except" | "exists" |
    "forall" | "from" | "group" | "implies" | "intersect" | "into" | "join" |
    "notelem" | "on" | "order" | "ordinal" | "require" | "skip" | "take" |
    "through" | "typeof" | "union" | "unorder" | "where" | "with" | "yield" |
    // Overloaded operators
    "inst" | "over"
}

// Top-level program
program = { SOI ~ (WHITE_SPACE | COMMENT)* ~ statement_semicolon+ ~ EOI }
program_single = { ws? ~ statement }
statement_semicolon = { statement ~ ";" }
statement = { decl | expr }
ws = { (WHITESPACE | COMMENT)* }

// Expressions with operator precedence (lowest to highest)
expr = { expr_annotated }

expr_annotated = { expr_implies ~ (":" ~ type_expr)? }

expr_implies = { expr_orelse ~ ("implies" ~ expr_orelse)* }

expr_orelse = { expr_andalso ~ ("orelse" ~ expr_andalso)* }

expr_andalso = { expr_o ~ ("andalso" ~ expr_o)* }

expr_o = { expr_comp ~ ("o" ~ expr_comp)* }

expr_comp = { expr_cons ~ (expr_comp_op ~ expr_comp)? }
expr_comp_op = { "=" | "<>" | "<" | ">" | "<=" | ">=" | "elem" | "notelem" }

expr_cons = { expr_additive ~ ("::" ~ expr_additive | "@" ~ expr_additive)* }

expr_additive = { expr_multiplicative ~ (("+" | "-" | "^") ~ expr_multiplicative)* }

expr_multiplicative = { expr_over ~ (("*" | "/" | "div" | "mod") ~ expr_over)* }

expr_over = { expr_unary ~ ("over" ~ expr_cons)? }

expr_unary = { "~" ~ expr_unary | expr_application }

expr_application = { expr_postfix ~ expr_postfix* }

expr_postfix = { atom ~ ("." ~ identifier)* }

atom = {
    literal |
    identifier |
    record_selector |
    "current" |
    "ordinal" |
    // Parenthesized expressions
    "(" ~ expr ~ ")" |
    // Tuples
    "(" ~ expr ~ ("," ~ expr)+ ~ ")" |
    // Lists
    "[" ~ (expr ~ ("," ~ expr)*)? ~ "]" |
    // Records
    "{" ~ (named_expr ~ ("," ~ named_expr)*)? ~ "}" |
    if_expr |
    case_expr |
    let_expr |
    fn_expr |
    // TODO: forall, exists
    from_expr
}

// Named expressions for records and relational clauses
named_expr = {
    identifier ~ "=" ~ expr |
    expr
}

// Control structures
if_expr = { "if" ~ expr ~ "then" ~ expr ~ "else" ~ expr }

case_expr = { "case" ~ expr ~ "of" ~ case_arms }
case_arms = { case_arm ~ ("|" ~ case_arm)* }
case_arm = { pat ~ "=>" ~ expr }

let_expr = { "let" ~ decl_list ~ "in" ~ expr ~ "end" }
decl_list = { decl ~ (";" ~ decl)* }

fn_expr = { "fn" ~ match_list }
match_list = { match_ ~ ("|" ~ match_)* }
match_ = { pat ~ "=>" ~ expr }

// Relational expressions (simplified)
from_expr = {
    "from" ~ scan_list? ~ step_list?
}

scan_list = { scan ~ ("," ~ scan)* }
first_scan = { pat ~ "in" ~ expr }
scan = { pat ~ "in" ~ expr ~ on? }

step_list = { step* }
step = {
    join |
    into_ |
    compute |
    distinct |
    except |
    intersect |
    union |
    unorder |
    require |
    skip |
    take
}

group_list = { named_expr ~ ("," ~ named_expr)* }
join = { "join" ~ pat ~ "in" ~ expr ~ on? }
on = { "on" ~ expr }
into_ = { "into" ~ pat ~ "in" ~ expr }
distinct = { "distinct" }
compute = { "compute" ~ expr }
unorder = { "unorder" ~ expr }
require = { "require" ~ expr }
except = { "except" ~ "all"? ~ expr ~ ("," ~ expr)* }
union = { "union" ~ "all"? ~ expr ~ ("," ~ expr)* }
intersect = { "intersect" ~ "all"? ~ expr ~ ("," ~ expr)* }
order = { "order" ~ expr }
skip = { "skip" ~ expr }
take = { "take" ~ expr }

// Patterns (fixed left-recursion)
pat = { pat_annotated }

pat_annotated = { pat_as ~ (":" ~ type_expr)? }

pat_as = { pat_cons ~ ("as" ~ identifier)? }

pat_cons = { pat_atom ~ ("::" ~ pat_cons)? }

pat_atom = {
    wildcard_pat |
    id_pat |
    literal_pat |
    tuple_pat |
    record_pat |
    list_pat |
    constructor_pat |
    "(" ~ pat ~ ")"
}

wildcard_pat = { "_" }
id_pat = { identifier }
literal_pat = { literal }
tuple_pat = { "(" ~ pat ~ ("," ~ pat)+ ~ ")" }
record_pat = { "{" ~ (pat_field ~ ("," ~ pat_field)* ~ ("," ~ ellipsis)? | ellipsis?) ~ "}" }
list_pat = { "[" ~ (pat ~ ("," ~ pat)*)? ~ "]" }
constructor_pat = { identifier ~ pat_atom? }
cons_pat = { pat ~ "::" ~ pat }

pat_field = { labeled_pat_field | anon_pat_field }
labeled_pat_field = { identifier ~ "=" ~ pat }
anon_pat_field = { pat }
ellipsis = { "..." }

// Declarations
decl = {
    val_decl |
    fun_decl |
    type_decl |
    datatype_decl
}

val_decl = { "val" ~ rec? ~ val_bind ~ ("and" ~ val_bind)* }
val_bind = { pat ~ (":" ~ type_expr)? ~ "=" ~ expr }
rec = { "rec" }

fun_decl = { "fun" ~ fun_bind ~ ("and" ~ fun_bind)* }
fun_bind = { identifier ~ match_list }

type_decl = { "type" ~ type_bind ~ ("and" ~ type_bind)* }
type_bind = { type_vars? ~ identifier ~ "=" ~ type_expr }

datatype_decl = { "datatype" ~ datatype_bind ~ ("and" ~ datatype_bind)* }
datatype_bind = { type_vars? ~ identifier ~ "=" ~ con_bind ~ ("|" ~ con_bind)* }
con_bind = { identifier ~ ("of" ~ type_expr)? }

// Types
type_expr = {
    type_fn
}

type_fn = { type_tuple ~ ("->" ~ type_tuple)* }

type_tuple = { type_app ~ ("*" ~ type_app)* }

type_app = { type_atom ~ type_atom* }

type_atom = {
    type_var |
    type_con |
    "(" ~ type_expr ~ ")" |
    "{" ~ (type_field ~ ("," ~ type_field)*)? ~ "}" |
    "(" ~ type_expr ~ ("," ~ type_expr)+ ~ ")"
}

type_var = { "'" ~ identifier }
type_con = { identifier }
type_field = { identifier ~ ":" ~ type_expr }
type_vars = { type_var | "(" ~ type_var ~ ("," ~ type_var)+ ~ ")" }

// Literals
literal = {
    numeric_literal |
    string_literal |
    char_literal |
    bool_literal |
    unit_literal
}

numeric_literal = {
    scientific_literal |
    real_literal |
    negative_integer_literal |
    non_negative_integer_literal
}

non_negative_integer_literal = @{ ASCII_DIGIT+ }
negative_integer_literal = @{ "~" ~ ASCII_DIGIT+ }
real_literal = @{ "~"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
scientific_literal = @{
    "~"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT*)? ~ ("e" | "E") ~ "~"? ~ ASCII_DIGIT+
}

string_literal = @{ "\"" ~ string_inner ~ "\"" }
string_inner = @{ (string_char | string_escape)* }
string_char = { !("\"" | "\\") ~ ANY }
string_escape = @{
    "\\" ~ ("\\" | "\"" | "a" | "b" | "t" | "n" | "v" | "f" | "r") |
    "\\" ~ "^" ~ ('@'..'^') |
    "\\" ~ ASCII_DIGIT{3}
}

char_literal = @{ "#" ~ string_literal }

bool_literal = { "true" | "false" }
unit_literal = { "()" }

// Identifiers
identifier = { quoted_identifier | unquoted_identifier }

unquoted_identifier = @{
    !keywords ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_" | "'")*
}

quoted_identifier = @{
    "`" ~ quoted_inner ~ "`"
}
quoted_inner = @{ (quoted_char | quoted_escape)* }
quoted_char = { !"`" ~ ANY }
quoted_escape = @{ "`" ~ "`" }

// Record selectors
record_selector = @{ "#" ~ (ASCII_ALPHANUMERIC | "_" | "'")+ }

// Type variables
ty_var = @{ "'" ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_" | "'")* }

// End morel.pest
