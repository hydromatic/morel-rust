// Licensed to Julian Hyde under one or more contributor license
// agreements.  See the NOTICE file distributed with this work
// for additional information regarding copyright ownership.
// Julian Hyde licenses this file to you under the Apache
// License, Version 2.0 (the "License"); you may not use this
// file except in compliance with the License.  You may obtain a
// copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
// either express or implied.  See the License for the specific
// language governing permissions and limitations under the
// License.

use crate::unify::unifier;
use crate::unify::unifier::{
    NullTracer, Substitution, UnificationFailure, Unifier,
};
use pest::Span;
use pest_consume::{Parser, match_nodes};
use std::rc::Rc;

type ParseInput<'input> = pest_consume::Node<'input, Rule, Rc<str>>;
pub type ParseError = pest::error::Error<Rule>;
pub type ParseResult<T> = Result<T, ParseError>;

/// Unifier parser generated by Pest.
#[derive(Parser)]
#[grammar = "src/unify/unifier.pest"]
pub struct UnifierParser;

#[derive(Debug)]
pub enum Term<'input> {
    Var(Span<'input>, &'input str),
    Atom(Span<'input>, &'input str),
    Sequence(Span<'input>, &'input str, Vec<Term<'input>>),
}

#[derive(Debug)]
pub struct Pair<'input> {
    pub left: Term<'input>,
    pub right: Term<'input>,
}

impl<'input> std::fmt::Display for Pair<'input> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{} = {}", self.left, self.right)
    }
}

impl<'input> std::fmt::Display for Term<'input> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Term::Var(_span, name) => write!(f, "{}", name),
            Term::Atom(_span, name) => write!(f, "{}", name),
            Term::Sequence(_span, name, args) => {
                if args.is_empty() {
                    write!(f, "{}", name)
                } else {
                    write!(
                        f,
                        "{}({})",
                        name,
                        args.iter()
                            .map(|arg| format!("{}", arg))
                            .collect::<Vec<_>>()
                            .join(", ")
                    )
                }
            }
        }
    }
}

/// Parses a unifier.
///
/// The statement may be preceded by whitespace and/or comments;
/// the statement must end with a semicolon.
#[allow(clippy::result_large_err)]
pub fn parse_pair_list<T>(
    input: &str,
    mut consumer: impl FnMut(Vec<Pair>) -> T,
) -> ParseResult<T> {
    let rc_input_str: Rc<str> = input.to_string().into();
    let nodes = UnifierParser::parse_with_userdata(
        Rule::pair_list,
        input,
        rc_input_str,
    )?;
    let pairs = match_nodes!(<UnifierParser>; nodes;
        [pair_list(e)] => e,
    );
    Ok(consumer(pairs))
}

#[pest_consume::parser(parser = UnifierParser)]
impl UnifierParser {
    fn program(input: ParseInput) -> ParseResult<Vec<Pair>> {
        Ok(match_nodes!(input.children();
            [pair_list(pairs)] => pairs,
        ))
    }

    fn pair_list(input: ParseInput) -> ParseResult<Vec<Pair>> {
        Ok(match_nodes!(input.children();
            [pair(pairs)..] => pairs.collect(),
        ))
    }

    fn pair(input: ParseInput) -> ParseResult<Pair> {
        Ok(match_nodes!(input.children();
            [term(left), term(right)] => Pair { left, right },
        ))
    }

    fn term(input: ParseInput) -> ParseResult<Term> {
        Ok(match_nodes!(input.children();
            [variable(v)] => v,
            [sequence(s)] => s,
        ))
    }

    fn variable(input: ParseInput) -> ParseResult<Term> {
        Ok(Term::Var(input.as_span(), input.as_str()))
    }

    fn sequence(input: ParseInput) -> ParseResult<Term> {
        Ok(match_nodes!(input.children();
            [atom(name)] => Term::Atom(input.as_span(), name),
            [atom(name), term(args)..] => {
                Term::Sequence(input.as_span(), name, args.collect())
            },
        ))
    }

    fn atom(input: ParseInput<'_>) -> ParseResult<&str> {
        Ok(input.as_str())
    }

    fn EOI(input: ParseInput) -> ParseResult<()> {
        Ok(())
    }
}

/// A job for the unifier, populated by parsing a list of term-pairs.
///
/// Here is an example program:
/// ```text
/// fn(T3, T1) = T2
/// int = T4
/// int = T5
/// tuple(T4, T5) = T3
/// fn(tuple(T7, T7), bool) = T2
/// bool = T1
/// string = T0
/// ```
///
pub struct UnifierTask {
    unifier: Unifier,
    pairs: Vec<(unifier::Term, unifier::Term)>,
}

impl UnifierTask {
    #[allow(clippy::result_large_err)]
    pub fn from_grammar(grammar: &str) -> Result<Self, ParseError> {
        let mut task = UnifierTask {
            unifier: Unifier::new(true),
            pairs: Vec::new(),
        };
        parse_pair_list(grammar, |pair_list| {
            task.convert_pair_list(&pair_list);
        })?;
        Ok(task)
    }

    fn convert_pair_list(&mut self, pair_list: &[Pair]) {
        // Convert parsed pairs to unifier terms and add them
        for pair in pair_list {
            let left_term = self.convert_term(&pair.left);
            let right_term = self.convert_term(&pair.right);
            self.pairs.push((left_term, right_term));
        }
    }

    fn convert_term(&mut self, term: &Term) -> unifier::Term {
        match term {
            Term::Var(_span, name) => {
                unifier::Term::Variable(self.unifier.variable_with_name(name))
            }
            Term::Atom(_span, name) => {
                let op = self.unifier.op(name, Some(0));
                unifier::Term::Sequence(self.unifier.atom(op))
            }
            Term::Sequence(_span, name, args) => {
                let arg_terms: Vec<unifier::Term> =
                    args.iter().map(|arg| self.convert_term(arg)).collect();
                let op = self.unifier.op(name, None);
                unifier::Term::Sequence(self.unifier.apply(op, &arg_terms))
            }
        }
    }

    /// Runs the unification.
    pub fn unify(&self) -> Result<Substitution, UnificationFailure> {
        let tracer = NullTracer; // switch to PrintTracer for debugging
        self.unifier.unify(self.pairs.as_slice(), &tracer, &[])
    }
}

/// Converts a list of term-pairs to a program
pub fn generate_program(
    term_pairs: &[(unifier::Term, unifier::Term)],
) -> String {
    let mut s = String::new();
    for p in term_pairs {
        s.push_str(&format!("{} = {}\n", p.0, p.1));
    }
    s
}
